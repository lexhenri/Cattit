var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Calls all subscribers once in a period.
 */
var Periodic = function () {

	/**
  * @param {number} period - The interval (in milliseconds).
  */
	function Periodic(period) {
		var _this = this;

		_classCallCheck(this, Periodic);

		this.subscribers = [];

		this.trigger = function (dry_run) {
			// Call all subscribers.
			for (var _iterator = _this.subscribers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref = _iterator[_i++];
				} else {
					_i = _iterator.next();
					if (_i.done) break;
					_ref = _i.value;
				}

				var subscriber = _ref;

				subscriber();
			}

			// Schedule next iteration.
			_this.schedule();
		};

		this.period = period;
	}
	// subscribers = new Set()


	_createClass(Periodic, [{
		key: "start",
		value: function start() {
			// Do nothing if already started.
			if (this.scheduled) {
				return;
			}

			// Start
			this.schedule();
		}
	}, {
		key: "schedule",
		value: function schedule() {
			this.scheduled = setTimeout(this.trigger, this.period);
		}
	}, {
		key: "stop",
		value: function stop() {
			clearTimeout(this.scheduled);
			this.scheduled = undefined;
		}
	}, {
		key: "add",
		value: function add(subscriber) {
			var _this2 = this;

			// Add subscriber.
			// this.subscribers.add(subscriber)
			if (this.subscribers.indexOf(subscriber) < 0) {
				this.subscribers.push(subscriber);
			}

			// If it's the first subscriber,
			// start this periodical.
			// if (this.subscribers.size === 1) {
			if (this.subscribers.length === 1) {
				this.start();
			}

			// Return unsubscribe function.
			return function () {
				return _this2.remove(subscriber);
			};
		}
	}, {
		key: "remove",
		value: function remove(subscriber) {
			// Remove subscriber.
			// this.subscribers.delete(subscriber)
			if (this.subscribers.indexOf(subscriber) >= 0) {
				this.subscribers.splice(this.subscribers.indexOf(subscriber), 1);
			}

			// If it was the last subscriber,
			// stop periodical time refresh.
			// if (this.subscribers.size === 0) {
			if (this.subscribers.length === 0) {
				this.stop();
			}
		}
	}, {
		key: "destroy",
		value: function destroy() {
			this.stop();
			// this.subscribers.clear()
			this.subscribers = [];
		}
	}]);

	return Periodic;
}();

export default Periodic;
//# sourceMappingURL=Periodic.js.map