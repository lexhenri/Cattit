var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import PropTypes from 'prop-types';
import JavascriptTimeAgo from 'javascript-time-ago';
import { style } from 'javascript-time-ago/prop-types';

import Periodic from './Periodic';
import createVerboseDateFormatter from './verboseDateFormatter';
import { getDate, isMockedDate } from './helpers/date';

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = React.PureComponent || React.Component;

var ReactTimeAgo = function (_PureComponent) {
	_inherits(ReactTimeAgo, _PureComponent);

	function ReactTimeAgo(props) {
		_classCallCheck(this, ReactTimeAgo);

		// Create `javascript-time-ago` formatter instance.
		var _this = _possibleConstructorReturn(this, (ReactTimeAgo.__proto__ || Object.getPrototypeOf(ReactTimeAgo)).call(this, props));
		// `this.props` are used in `.getPreferredLocales()`.


		_this.timeAgo = new JavascriptTimeAgo(_this.getPreferredLocales());

		// Create verbose date formatter for the tooltip text.
		// (only on client side, because tooltips aren't rendered until triggered)
		if (typeof window !== 'undefined') {
			var verboseDateFormat = _this.props.verboseDateFormat;

			_this.formatVerboseDate = createVerboseDateFormatter(_this.getPreferredLocales(), verboseDateFormat);
		}
		return _this;
	}

	_createClass(ReactTimeAgo, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var _props = this.props,
			    tick = _props.tick,
			    updateInterval = _props.updateInterval;

			// If time label autoupdates are enabled.

			if (tick) {
				// Run automatic time label updater (in a web browser).
				if (!window._react_time_ago_updater) {
					window._react_time_ago_updater = new Periodic(updateInterval);
				}

				// Register for the relative time autoupdate as the time goes by.
				this.stopAutoupdate = window._react_time_ago_updater.add(function () {
					return _this2.forceUpdate();
				});
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this.stopAutoupdate) {
				this.stopAutoupdate();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props2 = this.props,
			    _date = _props2.date,
			    timeStyle = _props2.timeStyle,
			    tooltip = _props2.tooltip,
			    container = _props2.container,
			    locale = _props2.locale,
			    locales = _props2.locales,
			    formatVerboseDate = _props2.formatVerboseDate,
			    verboseDateFormat = _props2.verboseDateFormat,
			    updateInterval = _props2.updateInterval,
			    tick = _props2.tick,
			    rest = _objectWithoutProperties(_props2, ['date', 'timeStyle', 'tooltip', 'container', 'locale', 'locales', 'formatVerboseDate', 'verboseDateFormat', 'updateInterval', 'tick']);

			// The date or timestamp that was passed.
			// Convert timestamp to `Date`.


			var date = getDate(_date);

			// Format verbose date for the tooltip.
			// (only on client side, because tooltips aren't rendered until triggered)
			var verboseDate = typeof window === 'undefined' ? undefined : this.getVerboseDate(date);

			var timeAgo = React.createElement(
				'time',
				_extends({
					dateTime: date.toISOString(),
					title: tooltip ? verboseDate : undefined
				}, rest),
				this.timeAgo.format(date, timeStyle)
			);

			if (container) {
				return React.createElement(container, _extends({
					verboseDate: verboseDate
				}, rest), timeAgo);
			}

			return timeAgo;
		}

		// Composes a list of preferred locales

	}, {
		key: 'getPreferredLocales',
		value: function getPreferredLocales() {
			var locale = this.props.locale;
			var locales = this.props.locales;

			// Convert `locale` to `locales`.

			if (locale) {
				locales = [locale];
			}

			// `javascript-time-ago` default locale.
			locales = locales.concat(JavascriptTimeAgo.getDefaultLocale());

			return locales;
		}

		// Verbose date string.
		// Is used as a tooltip text.
		//
		// E.g. "Sunday, May 18th, 2012, 18:45"
		//

	}, {
		key: 'getVerboseDate',
		value: function getVerboseDate(input) {
			var formatVerboseDate = this.props.formatVerboseDate;


			if (formatVerboseDate) {
				return formatVerboseDate(convertToDate(input));
			}

			return this.formatVerboseDate(convertToDate(input));
		}
	}]);

	return ReactTimeAgo;
}(PureComponent);

// Converts argument into a `Date`.


ReactTimeAgo.propTypes = {
	// The `date` or `timestamp`.
	// E.g. `new Date()` or `1355972400000`.
	date: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired,

	// Preferred locale.
	// Is 'en' by default.
	// E.g. 'ru-RU'.
	locale: PropTypes.string,

	// Preferred locales (ordered).
	// Will choose the first suitable locale from this list.
	// (the one that has been initialized)
	// E.g. `['ru-RU', 'en-GB']`.
	locales: PropTypes.arrayOf(PropTypes.string),

	// Date/time formatting style.
	// E.g. 'twitter', 'time', or custom (`{ gradation: […], units: […], flavour: 'long', custom: function }`)
	timeStyle: style,

	// Whether HTML `tooltip` attribute should be set
	// to verbosely formatted date (is `true` by default).
	// Set to `false` to disable the native HTML `tooltip`.
	tooltip: PropTypes.bool.isRequired,

	// An optional function returning what will be output in the HTML `title` tooltip attribute.
	// (by default it's `(date) => new Intl.DateTimeFormat(locale, {…}).format(date)`)
	formatVerboseDate: PropTypes.func,

	// `Intl.DateTimeFormat` format for the HTML `title` tooltip attribute.
	// Is used when `formatVerboseDate` is not specified.
	// By default outputs a verbose date.
	verboseDateFormat: PropTypes.object,

	// How often to update all `<ReactTimeAgo/>` elements on a page.
	// (is once in a minute by default)
	updateInterval: PropTypes.number,

	// Set to `false` to disable automatic refresh of
	// `<ReactTimeAgo/>` elements on a page as time goes by.
	// (is `true` by default)
	tick: PropTypes.bool,

	// React Component to wrap the resulting `<time/>` React Element.
	// Receives `verboseDate` and `children` properties.
	// `verboseDate` can be used for displaying verbose date label
	// in an "on mouse over" (or "on touch") tooltip.
	//
	// ```js
	// import React from 'react'
	// import ReactTimeAgo from 'react-time-ago'
	// import { Tooltip } from 'react-responsive-ui'
	// 
	// export default function TimeAgo(props) {
	//   return <ReactTimeAgo {...props} container={Container} tooltip={false}/>
	// }
	// 
	// const Container = ({ verboseDate, children }) => (
	//   <Tooltip content={verboseDate}>
	//     {children}
	//   </Tooltip>
	// )
	// ```
	//
	container: PropTypes.func
};
ReactTimeAgo.defaultProps = {
	locales: [],

	tooltip: true,

	// Thursday, December 20, 2012, 7:00:00 AM GMT+4
	verboseDateFormat: {
		weekday: 'long',
		day: 'numeric',
		month: 'long',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit',
		second: '2-digit'
		// timeZoneName : 'short'
	},

	// Updates once a minute
	updateInterval: 60 * 1000,

	// Refreshes time in a web browser by default
	tick: true
};
export default ReactTimeAgo;
function convertToDate(input) {
	if (input.constructor === Date || isMockedDate(input)) {
		return input;
	}

	if (typeof input === 'number') {
		return new Date(input);
	}

	throw new Error('Unsupported react-time-ago input: ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + ', ' + input);
}

// Deprecated CDN legacy export.
// Will be removed in version 6.x
ReactTimeAgo.default = ReactTimeAgo;

// ReactTimeAgo.addLocale = (data) => JavascriptTimeAgo.addLocale(data)
//# sourceMappingURL=ReactTimeAgo.js.map