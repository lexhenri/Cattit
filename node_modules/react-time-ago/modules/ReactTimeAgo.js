var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import React from 'react';
import PropTypes from 'prop-types';
import JavascriptTimeAgo from 'javascript-time-ago';
import { style } from 'javascript-time-ago/prop-types';

import createVerboseDateFormatter from './verboseDateFormatter';
import { getDate, getTime, isMockedDate } from './helpers/date';

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = React.PureComponent || React.Component;

var MINUTE = 60 * 1000;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = 30 * DAY;
var YEAR = 365 * DAY;

// For standard `timeStyle`s, "smart" autoupdate interval is used:
// every minute for the first hour, then every 10 minutes for the first 12 hours, and so on.
// "Smart" autoupdate intervals should be moved to `javascript-time-ago`'s grading scale.
var INTERVALS = [{
	interval: MINUTE
}, {
	threshold: HOUR,
	interval: 10 * MINUTE
}, {
	threshold: 12 * HOUR,
	interval: 20 * MINUTE
}, {
	threshold: DAY,
	interval: 3 * HOUR
}, {
	threshold: 7 * DAY,
	interval: 6 * HOUR
}, {
	threshold: MONTH,
	interval: 5 * DAY
}, {
	threshold: 3 * MONTH,
	interval: 10 * DAY
}, {
	threshold: YEAR,
	interval: MONTH
}];

// `setTimeout()` would enter an infinite cycle when interval is a `MONTH`.
// https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values
var SET_TIMEOUT_MAX_DELAY = 2147483647;

var ReactTimeAgo = function (_PureComponent) {
	_inherits(ReactTimeAgo, _PureComponent);

	function ReactTimeAgo(props) {
		_classCallCheck(this, ReactTimeAgo);

		// Create `javascript-time-ago` formatter instance.
		var _this = _possibleConstructorReturn(this, (ReactTimeAgo.__proto__ || Object.getPrototypeOf(ReactTimeAgo)).call(this, props));
		// `this.props` are used in `.getPreferredLocales()`.


		_this.timeAgo = new JavascriptTimeAgo(_this.getPreferredLocales());
		// Create verbose date formatter for the tooltip text.
		// (only on client side, because tooltips aren't rendered until triggered)
		if (typeof window !== 'undefined') {
			var verboseDateFormat = _this.props.verboseDateFormat;

			_this.formatVerboseDate = createVerboseDateFormatter(_this.getPreferredLocales(), verboseDateFormat);
		}
		return _this;
	}

	_createClass(ReactTimeAgo, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var tick = this.props.tick;
			// If time label autoupdates are enabled.

			if (tick) {
				this.scheduleNextTick();
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this.autoUpdateTimer);
		}
	}, {
		key: 'scheduleNextTick',
		value: function scheduleNextTick() {
			var _this2 = this;

			// Register for the relative time autoupdate as the time goes by.
			this.autoUpdateTimer = setTimeout(function () {
				_this2.forceUpdate();
				_this2.scheduleNextTick();
			}, this.getNextAutoUpdateDelay());
		}
	}, {
		key: 'getNextAutoUpdateDelay',
		value: function getNextAutoUpdateDelay() {
			var _props = this.props,
			    date = _props.date,
			    timeStyle = _props.timeStyle,
			    updateInterval = _props.updateInterval;
			// "Smart" autoupdate intervals are only used for standard time styles.

			if ((typeof timeStyle === 'undefined' ? 'undefined' : _typeof(timeStyle)) === 'object') {
				return updateInterval;
			}
			var time = getTime(date);
			var now = Date.now();
			var diff = Math.abs(now - time);
			var _interval = void 0;
			for (var _iterator = INTERVALS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
				var _ref;

				if (_isArray) {
					if (_i >= _iterator.length) break;
					_ref = _iterator[_i++];
				} else {
					_i = _iterator.next();
					if (_i.done) break;
					_ref = _i.value;
				}

				var _ref2 = _ref,
				    interval = _ref2.interval,
				    threshold = _ref2.threshold;

				if (threshold && diff < threshold) {
					continue;
				}
				_interval = interval;
			}
			return Math.min(_interval, SET_TIMEOUT_MAX_DELAY);
		}
	}, {
		key: 'render',
		value: function render() {
			var _props2 = this.props,
			    _date = _props2.date,
			    timeStyle = _props2.timeStyle,
			    tooltip = _props2.tooltip,
			    container = _props2.container,
			    locale = _props2.locale,
			    locales = _props2.locales,
			    formatVerboseDate = _props2.formatVerboseDate,
			    verboseDateFormat = _props2.verboseDateFormat,
			    updateInterval = _props2.updateInterval,
			    tick = _props2.tick,
			    rest = _objectWithoutProperties(_props2, ['date', 'timeStyle', 'tooltip', 'container', 'locale', 'locales', 'formatVerboseDate', 'verboseDateFormat', 'updateInterval', 'tick']);

			// The date or timestamp that was passed.
			// Convert timestamp to `Date`.


			var date = getDate(_date);

			// Format verbose date for the tooltip.
			// (only on client side, because tooltips aren't rendered until triggered)
			var verboseDate = typeof window === 'undefined' ? undefined : this.getVerboseDate(date);

			var timeAgo = React.createElement(
				'time',
				_extends({
					dateTime: date.toISOString(),
					title: tooltip ? verboseDate : undefined
				}, rest),
				this.timeAgo.format(date, timeStyle)
			);

			if (container) {
				return React.createElement(container, _extends({
					verboseDate: verboseDate
				}, rest), timeAgo);
			}

			return timeAgo;
		}

		// Composes a list of preferred locales

	}, {
		key: 'getPreferredLocales',
		value: function getPreferredLocales() {
			var locale = this.props.locale;
			var locales = this.props.locales;
			// Convert `locale` to `locales`.

			if (locale) {
				locales = [locale];
			}
			// `javascript-time-ago` default locale.
			return locales.concat(JavascriptTimeAgo.getDefaultLocale());
		}

		// Verbose date string.
		// Is used as a tooltip text.
		//
		// E.g. "Sunday, May 18th, 2012, 18:45"
		//

	}, {
		key: 'getVerboseDate',
		value: function getVerboseDate(input) {
			var formatVerboseDate = this.props.formatVerboseDate;

			if (formatVerboseDate) {
				return formatVerboseDate(convertToDate(input));
			}
			return this.formatVerboseDate(convertToDate(input));
		}
	}]);

	return ReactTimeAgo;
}(PureComponent);

export default ReactTimeAgo;


ReactTimeAgo.propTypes = {
	// The `date` or `timestamp`.
	// E.g. `new Date()` or `1355972400000`.
	date: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]).isRequired,

	// Preferred locale.
	// Is 'en' by default.
	// E.g. 'ru-RU'.
	locale: PropTypes.string,

	// Preferred locales (ordered).
	// Will choose the first suitable locale from this list.
	// (the one that has been initialized)
	// E.g. `['ru-RU', 'en-GB']`.
	locales: PropTypes.arrayOf(PropTypes.string),

	// Date/time formatting style.
	// E.g. 'twitter', 'time', or custom (`{ gradation: […], units: […], flavour: 'long', custom: function }`)
	timeStyle: style,

	// Whether HTML `tooltip` attribute should be set
	// to verbosely formatted date (is `true` by default).
	// Set to `false` to disable the native HTML `tooltip`.
	tooltip: PropTypes.bool.isRequired,

	// An optional function returning what will be output in the HTML `title` tooltip attribute.
	// (by default it's `(date) => new Intl.DateTimeFormat(locale, {…}).format(date)`)
	formatVerboseDate: PropTypes.func,

	// `Intl.DateTimeFormat` format for the HTML `title` tooltip attribute.
	// Is used when `formatVerboseDate` is not specified.
	// By default outputs a verbose date.
	verboseDateFormat: PropTypes.object,

	// How often to update all `<ReactTimeAgo/>` elements on a page.
	// (is once in a minute by default)
	// This setting is only used for "custom" `timeStyle`s.
	// For standard `timeStyle`s, "smart" autoupdate interval is used:
	// every minute for the first hour, then every 10 minutes for the first 12 hours, and so on.
	updateInterval: PropTypes.number,

	// Set to `false` to disable automatic refresh of
	// `<ReactTimeAgo/>` elements on a page as time goes by.
	// (is `true` by default)
	tick: PropTypes.bool,

	// React Component to wrap the resulting `<time/>` React Element.
	// Receives `verboseDate` and `children` properties.
	// `verboseDate` can be used for displaying verbose date label
	// in an "on mouse over" (or "on touch") tooltip.
	//
	// ```js
	// import React from 'react'
	// import ReactTimeAgo from 'react-time-ago'
	// import { Tooltip } from 'react-responsive-ui'
	// 
	// export default function TimeAgo(props) {
	//   return <ReactTimeAgo {...props} container={Container} tooltip={false}/>
	// }
	// 
	// const Container = ({ verboseDate, children }) => (
	//   <Tooltip content={verboseDate}>
	//     {children}
	//   </Tooltip>
	// )
	// ```
	//
	container: PropTypes.func
};

ReactTimeAgo.defaultProps = {
	// No preferred locales.
	locales: [],

	// Show verbose date `title` tooltip on mouse over.
	tooltip: true,

	// Thursday, December 20, 2012, 7:00:00 AM GMT+4
	verboseDateFormat: {
		weekday: 'long',
		day: 'numeric',
		month: 'long',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit',
		second: '2-digit'
		// timeZoneName : 'short'
	},

	// Updates once a minute
	updateInterval: MINUTE,

	// Refreshes time in a web browser by default
	tick: true

	// Converts argument into a `Date`.
};function convertToDate(input) {
	if (input.constructor === Date || isMockedDate(input)) {
		return input;
	}
	if (typeof input === 'number') {
		return new Date(input);
	}
	throw new Error('Unsupported react-time-ago input: ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + ', ' + input);
}

// Deprecated CDN legacy export.
// Will be removed in version 6.x
ReactTimeAgo.default = ReactTimeAgo;

// ReactTimeAgo.addLocale = (data) => JavascriptTimeAgo.addLocale(data)
//# sourceMappingURL=ReactTimeAgo.js.map