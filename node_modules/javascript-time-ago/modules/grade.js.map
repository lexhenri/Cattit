{"version":3,"sources":["../source/grade.js"],"names":["convenient","grade","elapsed","now","units","gradation","getAllowedSteps","length","i","findGradationStep","step","granularity","amount","Math","round","abs","factor","getThreshold","fromStep","toStep","future","threshold","id","unit","undefined","type","Error","JSON","stringify","filter","indexOf"],"mappings":"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","sourcesContent":["import { convenient } from './gradation'\r\n\r\n/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds). Is < 0 for past dates and > 0 for future dates.\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */\r\nexport default function grade(elapsed, now, units, gradation = convenient)\r\n{\r\n\t// Leave only allowed time measurement units.\r\n\t// E.g. omit \"quarter\" unit.\r\n\tgradation = getAllowedSteps(gradation, units)\r\n\r\n\t// If no steps of gradation fit the conditions\r\n\t// then return nothing.\r\n\tif (gradation.length === 0) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Find the most appropriate gradation step\r\n\tconst i = findGradationStep(elapsed, now, gradation)\r\n\tconst step = gradation[i]\r\n\r\n\t// If time elapsed is too small and even\r\n\t// the first gradation step doesn't suit it\r\n\t// then return nothing.\r\n\tif (i === -1) {\r\n\t\treturn\r\n\t}\r\n\r\n\t// Apply granularity to the time amount\r\n\t// (and fall back to the previous step\r\n\t//  if the first level of granularity\r\n\t//  isn't met by this amount)\r\n\tif (step.granularity) {\r\n\t\t// Recalculate the elapsed time amount based on granularity\r\n\t\tconst amount = Math.round((Math.abs(elapsed) / step.factor) / step.granularity) * step.granularity\r\n\t\t// If the granularity for this step\r\n\t\t// is too high, then fallback\r\n\t\t// to the previous step of gradation.\r\n\t\t// (if there is any previous step of gradation)\r\n\t\tif (amount === 0 && i > 0) {\r\n\t\t\treturn gradation[i - 1]\r\n\t\t}\r\n\t}\r\n\r\n\treturn step\r\n}\r\n\r\n/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @param  {boolean} future - Is `true` for future dates (\"in 5 minutes\").\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */\r\nfunction getThreshold(fromStep, toStep, now, future)\r\n{\r\n\tlet threshold\r\n\r\n\t// Allows custom thresholds when moving\r\n\t// from a specific step to a specific step.\r\n\tif (fromStep && (fromStep.id || fromStep.unit)) {\r\n\t\tthreshold = toStep[`threshold_for_${fromStep.id || fromStep.unit}`]\r\n\t}\r\n\r\n\t// If no custom threshold is set for this transition\r\n\t// then use the usual threshold for the next step.\r\n\tif (threshold === undefined) {\r\n\t\tthreshold = toStep.threshold\r\n\t}\r\n\r\n\t// Convert threshold to a number.\r\n\tif (typeof threshold === 'function') {\r\n\t\tthreshold = threshold(now, future)\r\n\t}\r\n\r\n\t// Throw if no threshold is found.\r\n\tif (fromStep && typeof threshold !== 'number') {\r\n\t\t// Babel transforms `typeof` into some \"branches\"\r\n\t\t// so istanbul will show this as \"branch not covered\".\r\n\t\t/* istanbul ignore next */\r\n\t\tconst type = typeof threshold\r\n\t\tthrow new Error(`Each step of a gradation must have a threshold defined except for the first one. Got \"${threshold}\", ${type}. Step: ${JSON.stringify(toStep)}`)\r\n\t}\r\n\r\n\treturn threshold\r\n}\r\n\r\n/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */\r\nfunction findGradationStep(elapsed, now, gradation, i = 0)\r\n{\r\n\t// If the threshold for moving from previous step\r\n\t// to this step is too high then return the previous step.\r\n\tif (Math.abs(elapsed) < getThreshold(gradation[i - 1], gradation[i], now, elapsed < 0)) {\r\n\t\treturn i - 1\r\n\t}\r\n\t// If it's the last step of gradation then return it.\r\n\tif (i === gradation.length - 1) {\r\n\t\treturn i\r\n\t}\r\n\t// Move to the next step.\r\n\treturn findGradationStep(elapsed, now, gradation, i + 1)\r\n}\r\n\r\n/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */\r\nfunction getAllowedSteps(gradation, units)\r\n{\r\n\treturn gradation.filter(({ unit }) => {\r\n\t\t// If this step has a `unit` defined\r\n\t\t// then this `unit` must be in the list of `units` allowed.\r\n\t\tif (unit) {\r\n\t\t\treturn units.indexOf(unit) >= 0\r\n\t\t}\r\n\t\t// A gradation step is not required to specify a `unit`.\r\n\t\t// E.g. for Twitter gradation it specifies `format()` instead.\r\n\t\treturn true\r\n\t})\r\n}"],"file":"grade.js"}