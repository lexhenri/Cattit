'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _reactCreateRef = require('react-create-ref');

var _reactCreateRef2 = _interopRequireDefault(_reactCreateRef);

var _grid = require('./utility/grid');

var _dom = require('./utility/dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function TextInput(_ref, ref) {
	var id = _ref.id,
	    value = _ref.value,
	    multiline = _ref.multiline,
	    inputComponent = _ref.inputComponent,
	    focus = _ref.focus,
	    onChange = _ref.onChange,
	    onKeyDown = _ref.onKeyDown,
	    disabled = _ref.disabled,
	    label = _ref.label,
	    placeholder = _ref.placeholder,
	    type = _ref.type,
	    autoresize = _ref.autoresize,
	    indicateInvalid = _ref.indicateInvalid,
	    error = _ref.error,
	    originalInputStyle = _ref.inputStyle,
	    className = _ref.className,
	    containerRef = _ref.containerRef,
	    floatingLabel = _ref.floatingLabel,
	    required = _ref.required,
	    children = _ref.children,
	    rest = _objectWithoutProperties(_ref, ['id', 'value', 'multiline', 'inputComponent', 'focus', 'onChange', 'onKeyDown', 'disabled', 'label', 'placeholder', 'type', 'autoresize', 'indicateInvalid', 'error', 'inputStyle', 'className', 'containerRef', 'floatingLabel', 'required', 'children']);

	var input = (0, _react.useRef)();
	var hiddenTextArea = (0, _react.useRef)();
	// hiddenTextAreaSingleLine = createRef()

	var autoResize = (0, _react.useMemo)(function () {
		if (multiline && autoresize) {
			return new Autoresize(function () {
				return input.current;
			}, function () {
				return hiddenTextArea.current;
			});
		}
	}, []);

	// On component update.
	(0, _react.useEffect)(function () {
		if (multiline && autoresize) {
			if (autoResize.initialized) {
				autoResize.resize();
			}
		}
	});

	// Client side rendering, javascript is enabled
	(0, _react.useEffect)(function () {
		if (multiline && autoresize) {
			// Doing `this.init()` here
			// because `<textarea/>` should autoresize
			// in case its `value` is set up front.
			autoResize.init();
			var onWindowResize = (0, _throttle2.default)(function (event) {
				return autoResize.resize();
			}, 100);
			window.addEventListener('resize', onWindowResize);
			return function () {
				window.removeEventListener('resize', onWindowResize);
			};
		}
	}, []);

	// The underlying `input` component
	// can pass both `event`s and `value`s
	// to this parent `onChange` listener.
	var _onChange = (0, _react.useCallback)(function (event) {
		// Extract `value` from the argument
		// of this `onChange` listener
		// (for convenience)
		var newValue = event;
		if (event && event.target) {
			newValue = event.target.value;
		}
		// Call the parent `onChange` handler
		// with the `value` as an argument (for convenience).
		// Call `onChange` only if `value` did actually change
		if (newValue !== value) {
			onChange(newValue);
		}
	}, [value, onChange]);

	var _onKeyDown = (0, _react.useCallback)(function (event) {
		if (onKeyDown) {
			onKeyDown(event);
		}
		if (event.defaultPrevented) {
			return;
		}
		if ((0, _dom.submitFormOnCtrlEnter)(event, input.current)) {
			return;
		}
	}, [onKeyDown, input]);

	var storeInputNode = (0, _react.useCallback)(function (node) {
		if (ref) {
			if (typeof ref === 'function') {
				ref(node);
			} else {
				ref.current = node;
			}
		}
		input.current = node;
	}, [input, ref]);

	var inputStyle = (0, _react.useMemo)(function () {
		if (multiline && autoresize) {
			return _extends({
				resize: 'none'
			}, originalInputStyle);
		}
		return originalInputStyle;
	}, [multiline, autoresize, originalInputStyle]);

	var properties = _extends({
		// Placed `autoFocus` before `...rest` so that
		// it doesn't override an already passed `autoFocus`.
		// `focus` property is deprecated. Use `autoFocus` instead.
		autoFocus: focus
	}, rest, {
		id: id,
		ref: storeInputNode,
		value: isEmptyValue(value) ? '' : value,
		disabled: disabled,
		'aria-label': rest['aria-label'] || (id && label ? undefined : label),
		'aria-required': rest['aria-required'] || (required ? true : undefined),
		'aria-invalid': rest['aria-invalid'] || (error && indicateInvalid ? true : undefined),
		placeholder: placeholder,
		onChange: _onChange,
		onKeyDown: _onKeyDown,
		style: inputStyle,
		className: (0, _classnames2.default)(className,
		// `<TextInput/>` has `border-color` to indicate its `:focus` state.
		// Therefore the `outline` can be safely removed.
		'rrui__outline', 'rrui__input-element', 'rrui__input-field', {
			// CSS selector performance optimization
			'rrui__input-field--invalid': indicateInvalid && error,
			'rrui__input-field--disabled': disabled,
			'rrui__input-field--multiline': multiline
		})

		// In case of `multiline` set to `true`
		// this is gonna be a `<textarea/>`
	});if (multiline) {
		if (autoresize) {
			return [
			// <textarea
			// 	key="textarea-measurement-single-line"
			// 	ref={this.hiddenTextAreaSingleLine}
			// 	rows="1"
			// 	readOnly
			// 	aria-hidden="true"
			// 	value=""
			// 	tabIndex={-1}
			// 	className={properties.className}
			// 	style={inputStyle ? { ...inputStyle, ...HIDDEN_TEXTAREA_STYLE } : HIDDEN_TEXTAREA_STYLE}/>,

			_react2.default.createElement('textarea', {
				key: 'textarea-measurement',
				ref: hiddenTextArea,
				readOnly: true,
				'aria-hidden': true,
				value: properties.value,
				rows: properties.rows,
				tabIndex: -1,
				className: properties.className,
				style: inputStyle ? _extends({}, inputStyle, HIDDEN_TEXTAREA_STYLE) : HIDDEN_TEXTAREA_STYLE }), _react2.default.createElement('textarea', _extends({
				key: 'textarea'
			}, properties))];
		}

		return _react2.default.createElement('textarea', _extends({ key: 'textarea' }, properties));
	}

	// Add `<input/>` `type` property.
	if (inputComponent === 'input') {
		properties.type = type || 'text';
	}

	return _react2.default.createElement(inputComponent, properties);
}

TextInput = _react2.default.forwardRef(TextInput);

TextInput.propTypes = {
	// (optional) HTML `id` attribute.
	id: _propTypes2.default.string,

	// `<input type/>` attribute.
	type: _propTypes2.default.string,

	// Whether `<textarea/>` should autoresize itself
	// (is `true` by default)
	autoresize: _propTypes2.default.bool.isRequired,

	// In order for this to work properly
	// `<textarea/>` vertical padding should be `0`
	// and instead the padding should be defined on `<textarea/>` parent `<div/>`
	// like it's done in Material UI.
	// Otherwise it won't look pretty and the line of text near the top border
	// will be partially visible resulting in weird UX.
	// If `<textarea/>` vertical padding was `0`
	// the line of text near the top border wouldn't be visible.
	// // The maximum number of rows <textarea/> grows up to.
	// rowsMax          : PropTypes.number.isRequired,

	// Set to `false` to prevent the `<label/>` from floating
	floatingLabel: _propTypes2.default.bool.isRequired,

	// A custom input component.
	// (is `<input/>` by default)
	inputComponent: _propTypes2.default.elementType.isRequired,

	// Indicates that the input is invalid.
	error: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.bool])
};

TextInput.defaultProps = {
	// `<textarea/>` should autoresize itself
	autoresize: true,

	// Set to `false` to prevent the `<label/>` from floating
	floatingLabel: true,

	// A custom input component.
	// (is `<input/>` by default)
	inputComponent: 'input'

	// // The maximum number of rows <textarea/> grows up to.
	// rowsMax : 12
};

exports.default = TextInput;

// https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js

var HIDDEN_TEXTAREA_STYLE = {
	// Overflow also needed to here to remove the extra row
	// added to `<textarea/>`s in Firefox.
	overflow: 'hidden',
	// Visibility needed to hide the extra `<textarea/>` on iPads.
	visibility: 'hidden',
	position: 'absolute',
	// Don't know why is it here.
	whiteSpace: 'pre-wrap'
};

function isEmptyValue(value) {
	return value === '' || value === undefined || value === null;
}

var Autoresize = function () {
	function Autoresize(getInput, getHiddenTextArea) {
		var _this = this;

		_classCallCheck(this, Autoresize);

		this.currentHeight = 0;
		this.verticalPadding = 0;
		this.bordersHeight = 0;
		this.initAttempts = 0;

		this.init = function () {
			// Exit if the component is no longer mounted.
			if (!_this.getInput()) {
				return;
			}
			_this.initAttempts++;
			_this.getMeasurements();
			if (_this.haveStylesLoaded()) {
				_this.resize();
			}
			_this.initialized = true;
			// Even if padding on <textarea/> has been set
			// it's still possible that `font-size` hasn't been set yet.
			// Or it could be another padding in a subsequent stylesheet.
			// So keep re-initializing <textarea/>, say, for a second.
			if (_this.initAttempts <= 5) {
				setTimeout(_this.init, 200);
			}
		};

		this.getInput = getInput;
		this.getHiddenTextArea = getHiddenTextArea;
	}

	// Copy-pasted from Material UI on Oct 24th, 2018.
	// https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js


	_createClass(Autoresize, [{
		key: 'resize',
		value: function resize() {
			var hiddenTextArea = this.getHiddenTextArea();
			// Guarding for **broken** shallow rendering method that call componentDidMount
			// but doesn't handle refs correctly.
			// To remove once the shallow rendering has been fixed.
			if (!hiddenTextArea) {
				return;
			}
			// const lineHeight = this.hiddenTextAreaSingleLine.current.scrollHeight - verticalPadding.current
			var height = hiddenTextArea.scrollHeight;
			// Guarding for jsdom, where scrollHeight isn't present.
			// See https://github.com/tmpvar/jsdom/issues/1013
			if (height === undefined) {
				return;
			}
			// It would have to first subtract `paddingTop` and `paddingBottom`,
			// then it would calculate `rowsMax * lineHeight` and
			// then it would re-add `paddingTop` and `paddingBottom`.
			// height = Math.min(rowsMax * lineHeight + verticalPadding.current, height)
			//
			// `.scrollHeight` doesn't include borders.
			// `.style.height` does include borders.
			height += this.bordersHeight;
			//
			// if (height <= this.minHeight) {
			// 	height = this.minHeight
			// }
			// For some weird reason Chrome on Windows 10
			// requires an extra pixel been added
			// to avoid showing vertical scrollbar.
			// (Oct 24th, 2018)
			// else {
			height += 1;
			// }
			//
			// "Need a large enough different to update the height.
			//  This prevents infinite rendering loop."
			// It's unclear what loop they're talking about.
			if (Math.abs(this.currentHeight - height) > 1) {
				this.currentHeight = height;
				// `.style.height` includes borders.
				this.getInput().style.height = height + 'px';
			}
		}

		// `height` works incorrectly in some weird cases.
		// For example, when `<textarea/>` is hidden when mounted
		// or when there's no stylesheet loaded yet.
		// For example, when stylesheets are included "dynamically"
		// like Webpack's `style-loader` does (is used in development mode,
		// or when using "code splitting" when "chunks" are `import()`ed dynamically).
		//
		// https://stackoverflow.com/questions/39400038/how-to-ensure-that-hot-css-loads-before-js-in-webpack-dev-server
		// https://github.com/webpack-contrib/style-loader/issues/269
		//
		// An alternative solution would be:
		//
		// input.current.minHeight = 0
		// input.current.minHeight = input.current.scrollHeight + bordersHeight.current
		//
		// or:
		//
		// input.current.minHeight = hiddenTextArea.current.scrollHeight + bordersHeight.current
		//
		// which wouldn't ever undersize the <textarea/>
		// but it would oversize it due to the incorrect
		// <textarea/> width before styles are loaded.
		//

	}, {
		key: 'getMeasurements',
		value: function getMeasurements() {
			var style = getComputedStyle(this.getInput());

			// // Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			// // `style.height` includes borders.
			// currentHeight.current = Math.ceil(parseFloat(style.height))
			// this.minHeight = currentHeight.current

			// Get vertical padding.
			// Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			this.verticalPadding = Math.ceil(parseFloat(style.paddingTop)) + Math.ceil(parseFloat(style.paddingBottom));

			// Top and bottom borders are extra height,
			// because `.scrollHeight` doesn't include borders.
			// Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			this.bordersHeight = Math.ceil(parseFloat(style.borderTopWidth)) + Math.ceil(parseFloat(style.borderBottomWidth));
		}

		// Even if padding on <textarea/> has been set
		// it's still possible that `font-size` hasn't been set yet.
		// (it happened in a project)
		// So this function doesn't guarantee anything.

	}, {
		key: 'haveStylesLoaded',
		value: function haveStylesLoaded() {
			// The default <textarea/> top/bottom padding in Chrome on Windows is 2px.
			// `react-responsive-ui` multiline text inputs are supposed to have larger padding.
			return this.verticalPadding > 2 * 2;
		}
	}]);

	return Autoresize;
}();
//# sourceMappingURL=TextInputInput.js.map