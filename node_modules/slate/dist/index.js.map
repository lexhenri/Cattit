{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/utils/weak-maps.ts","../src/create-editor.ts","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../src/utils/string.ts","../src/interfaces/editor.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Editor.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: () => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor)\n      }\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const child = node.children[i] as Descendant\n        const prev = node.children[i - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { createDraft, finishDraft, isDraft } from 'immer'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  Descendant,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface Editor {\n  children: Node[]\n  selection: Range | null\n  operations: Operation[]\n  marks: Record<string, any> | null\n  [key: string]: any\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: () => void\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport const Editor = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(editor: Editor): void {\n    editor.deleteFragment()\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    return (\n      isPlainObject(value) &&\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    )\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Iterable<NodeEntry<T>> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Record<string, any> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.last(editor, at)\n    const [, to] = Editor.last(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Iterable<NodeEntry<T>> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const iterable = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of iterable) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ) {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = getDirtyPaths(editor).pop()!\n        const entry = Editor.node(editor, path)\n        editor.normalizeNode(entry)\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Iterable<Point> {\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        if (editor.isInline(node)) {\n          continue\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          const text = Editor.string(editor, { anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.first(editor, at)\n    const [, to] = Editor.first(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  string(editor: Editor, at: Location): string {\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath))\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    fn()\n    NORMALIZING.set(editor, value)\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\ntype NodeMatch<T extends Node> =\n  | ((node: Node) => node is T)\n  | ((node: Node) => boolean)\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface Element {\n  children: Node[]\n  [key: string]: any\n}\n\nexport const Element = {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport const Location = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport const Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Element, ElementEntry, Path, Range, Text } from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type Node = Editor | Element | Text\n\nexport const Node = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry<Ancestor>> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry<Descendant>> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry<Descendant>> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return an iterable of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce(root, r => {\n      const [start, end] = Range.edges(range)\n      const iterable = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of iterable) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.selection\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  },\n\n  /**\n   * Get the lash node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return an iterable of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return an iterable of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry<Text>> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n","import { Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\nexport type InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\nexport type MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\nexport type MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: any\n}\n\nexport type RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\nexport type RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\nexport type SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: any\n}\n\nexport type SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Range\n      newProperties: null\n    }\n\nexport type SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport const Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // We need to get the original path here, but sometimes the `newPath`\n        // is a younger sibling of (or ends before) the original, and this\n        // accounts for it.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport const Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              const i = Math.min(onp.length, op.length) - 1\n              copy[i] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport const PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface Point {\n  path: Path\n  offset: number\n  [key: string]: any\n}\n\nexport const Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport const PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: any\n}\n\nexport const Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Iterable<PointEntry> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport const RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Range } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface Text {\n  text: string\n  [key: string]: any\n}\n\nexport const Text = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    for (const key in text) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    for (const key in another) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= offset + length) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range starts after the leaf, or ends before it, continue.\n        if (\n          start.offset > offset + length ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < offset + length) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Transforms,\n} from '..'\n\nexport const GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath))\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n} from '..'\n\nexport const NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const [parent, parentPath] = Editor.node(editor, Path.parent(path))\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n =>\n          levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          target: null,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n      let target: number | null = null\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const { text, children, ...properties } = node\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            target,\n            properties,\n          })\n        }\n\n        target = position\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'highest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const [commonNode] = Editor.node(editor, commonPath)\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport const SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor) {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location) {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n    const newPoint = Object.assign(point, props)\n\n    if (edge === 'anchor') {\n      Transforms.setSelection(editor, { anchor: newPoint })\n    } else {\n      Transforms.setSelection(editor, { focus: newPoint })\n    }\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>) {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport const TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n"],"names":["DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","apply","op","ref","Editor","pathRefs","PathRef","transform","pointRefs","PointRef","rangeRefs","RangeRef","set","Set","dirtyPaths","add","path","key","join","has","push","oldDirtyPaths","get","newDirtyPaths","getDirtyPaths","newPath","Path","normalize","type","Promise","resolve","then","addMark","value","Range","isExpanded","Transforms","setNodes","match","Text","isText","split","deleteBackward","unit","isCollapsed","delete","reverse","deleteForward","deleteFragment","insertBreak","splitNodes","always","insertFragment","fragment","insertNode","node","insertNodes","insertText","text","inline","above","n","mode","inlinePath","isEnd","anchor","point","after","setSelection","focus","normalizeNode","entry","Element","isElement","length","child","at","concat","voids","shouldHaveInlines","isEditor","i","prev","isLast","isInlineOrText","removeNodes","newChild","equals","loose","mergeNodes","removeMark","unsetNodes","levels","descendants","Array","from","Node","nodes","p","ancestors","previousPath","previous","oldAncestors","newAncestors","ancestor","nextPath","next","objectWithoutPropertiesLoose","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","offset","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","started","char","charAt","l","slice","rest","isWordCharacter","remaining","test","code","options","edge","end","range","distance","d","target","positions","before","start","edges","first","hasBlocks","element","some","isBlock","hasInlines","hasTexts","every","isPlainObject","isRange","isNodeList","Operation","isOperationList","Point","isEdge","isStart","isEmpty","isNormalizing","undefined","last","leaf","block","prevNode","prevPath","blockPath","isAncestor","to","span","isPath","Error","parent","includes","universal","Span","isSpan","iterable","pass","matches","hit","isLower","compare","emit","force","allPaths","withoutNormalizing","max","m","pop","parentPath","depth","firstPath","lastPath","common","isPoint","pathRef","affinity","current","unref","refs","pointRef","string","available","isNewBlock","advance","e","s","reverseText","isFirst","rangeRef","t","createDraft","index","splice","points","truePath","newParent","newIndex","result","texts","newProperties","JSON","stringify","Object","assign","position","properties","newNode","finishDraft","isDraft","unhangRange","endBlock","skip","isBefore","void","fn","isElementList","isArray","props","Location","isLocation","root","c","childPath","another","descendant","elements","newRoot","produce","r","isNode","visited","isAfter","nextIndex","map","isNodeOperation","isOperation","endsWith","isSelectionOperation","isTextOperation","inverse","inversePath","inverseNewPath","paths","av","bv","min","Math","endsAfter","as","bs","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","isSibling","al","bl","list","relative","operation","onp","copy","isBackward","rs","re","ts","te","isAfterStart","isBeforeEnd","intersection","s1","e1","s2","e2","isForward","affinityAnchor","affinityFocus","isTextList","decorations","leaves","dec","o","middle","off","GeneralTransforms","NodeTransforms","hanging","select","matchPath","isAtEnd","liftNodes","toPath","moveNodes","splitPath","commonPath","isPreviousSibling","emptyAncestor","emptyRef","toRef","targets","depths","splitMode","k","keys","height","deleteRange","beforeRef","highest","voidMatch","nudge","voidNode","voidPath","afterPath","siblingHeight","afterRef","highestPath","lowestPath","obj","unwrapNodes","wrapNodes","roots","rootPath","a","commonNode","wrapperPath","wrapper","SelectionTransforms","collapse","deselect","move","opts","setPoint","newPoint","oldProps","newProps","TextTransforms","furthestVoid","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","inlineMatch","isInlineStart","isInlineEnd","middleRef"],"mappings":"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"}