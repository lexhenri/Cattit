{"version":3,"sources":["../../source/CLDR/extractRelativeTimeMessages.js"],"names":["UNITS","short","narrow","extractRelativeTimeMessages","localeData","locale","Object","keys","main","timeUnitsFormattingRules","dates","fields","filter","unit","indexOf","parseUnit","reduce","_unit","type","setUnitRules","extractTimeUnitFormattingRules","rulesCLDR","rules","previousIndex","current","nextIndex","past","quantifier","replace","other","length","future","test"],"mappings":"AAAA;AAEA,SAASA,KAAT,QAAsB,uBAAtB,C,CAEA;AACA;AACA;AACA;;AACA,IAAMC,KAAK,GAAG,SAAd;AACA,IAAMC,MAAM,GAAG,UAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,2BAAT,CAAqCC,UAArC,EACf;AACC;AACA,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYH,UAAU,CAACI,IAAvB,EAA6B,CAA7B,CAAf;AACA,MAAMC,wBAAwB,GAAGL,UAAU,CAACI,IAAX,CAAgBH,MAAhB,EAAwBK,KAAxB,CAA8BC,MAA/D;AAEA,SAAOL,MAAM,CAACC,IAAP,CAAYE,wBAAZ,EACLG,MADK,CACE,UAACC,IAAD,EAAU;AACjB;AACA;AACA,WAAOb,KAAK,CAACc,OAAN,CAAcC,SAAS,CAACF,IAAD,CAAT,CAAgBA,IAA9B,KAAuC,CAA9C;AACA,GALK,EAMLG,MANK,CAME,UAACZ,UAAD,EAAaa,KAAb,EAAuB;AAAA,qBACPF,SAAS,CAACE,KAAD,CADF;AAAA,QACtBJ,IADsB,cACtBA,IADsB;AAAA,QAChBK,IADgB,cAChBA,IADgB;;AAE9B,WAAOC,YAAY,CAACf,UAAD,EAAac,IAAb,EAAmBL,IAAnB,EAAyBO,8BAA8B,CAACX,wBAAwB,CAACQ,KAAD,CAAzB,CAAvD,CAAnB;AACA,GATK,EASH,EATG,CAAP;AAUA;AAED;;;;;;AAKA,SAASG,8BAAT,CAAwCC,SAAxC,EACA;AACC,MAAIC,KAAK,GAAG,EAAZ,CADD,CAGC;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,aAAa,GAAG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","sourcesContent":["// import { isEqual } from 'lodash'\r\n\r\nimport { UNITS } from '../RelativeTimeFormat'\r\n\r\n// Detects short and narrow flavours of labels (yr., mo., etc).\r\n// E.g. there are \"month\", \"month-short\", \"month-narrow\".\r\n// More on \"narrow\" vs \"short\":\r\n// http://cldr.unicode.org/translation/plurals#TOC-Narrow-and-Short-Forms\r\nconst short = /-short$/\r\nconst narrow = /-narrow$/\r\n\r\n// Converts locale data from CLDR format to this library's format.\r\n//\r\n// CLDR locale data example:\r\n//\r\n// ```json\r\n// {\r\n//   \"main\": {\r\n//     \"en-US-POSIX\": {\r\n//       \"identity\": {\r\n//         \"language\": \"en\",\r\n//         ...\r\n//       },\r\n//       \"dates\": {\r\n//         \"fields\": {\r\n//           \"year\": {\r\n//             \"displayName\": \"year\",\r\n//             \"relative-type--1\": \"last year\",\r\n//             \"relative-type-0\": \"this year\",\r\n//             \"relative-type-1\": \"next year\",\r\n//             \"relativeTime-type-future\": {\r\n//               \"relativeTimePattern-count-one\": \"in {0} year\",\r\n//               \"relativeTimePattern-count-other\": \"in {0} years\"\r\n//             },\r\n//             \"relativeTime-type-past\": {\r\n//               \"relativeTimePattern-count-one\": \"{0} year ago\",\r\n//               \"relativeTimePattern-count-other\": \"{0} years ago\"\r\n//             }\r\n//           },\r\n// ...\r\n// ```\r\n//\r\n// Parsed locale data example:\r\n//\r\n// ```json\r\n// {\r\n// \t\"long\":\r\n// \t{\r\n// \t\t...\r\n// \t\t\"second\": [\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"a second ago\",\r\n// \t\t\t\t\"other\": \"{0} seconds ago\"\r\n// \t\t\t},\r\n// \t\t\t{\r\n// \t\t\t\t\"one\": \"in a second\",\r\n// \t\t\t\t\"other\": \"in {0} seconds\"\r\n// \t\t\t}\r\n// \t\t],\r\n// \t\t...\r\n// \t},\r\n// \t\"short\":\r\n// \t{\r\n// \t\t...\r\n// \t},\r\n// \t...\r\n// }\r\n// ```\r\nexport default function extractRelativeTimeMessages(localeData)\r\n{\r\n\t// Extract `locale` from CLDR locale data.\r\n\tconst locale = Object.keys(localeData.main)[0]\r\n\tconst timeUnitsFormattingRules = localeData.main[locale].dates.fields\r\n\r\n\treturn Object.keys(timeUnitsFormattingRules)\r\n\t\t.filter((unit) => {\r\n\t\t\t// Take only the generic time measurement units\r\n\t\t\t// (skip exotic ones like \"fri\" on \"thu\").\r\n\t\t\treturn UNITS.indexOf(parseUnit(unit).unit) >= 0\r\n\t\t})\r\n\t\t.reduce((localeData, _unit) => {\r\n\t\t\tconst { unit, type } = parseUnit(_unit)\r\n\t\t\treturn setUnitRules(localeData, type, unit, extractTimeUnitFormattingRules(timeUnitsFormattingRules[_unit]))\r\n\t\t}, {})\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit formatting rules.\r\n * @param  {object} - CLDR time unit formatting rules.\r\n * @return {(object|string)}\r\n */\r\nfunction extractTimeUnitFormattingRules(rulesCLDR)\r\n{\r\n\tlet rules = {}\r\n\r\n\t// \"relative\" values aren't suitable for \"ago\" or \"in a\" cases,\r\n\t// because \"1 year ago\" != \"last year\" (too vague for Jan 30th)\r\n\t// and \"in 0.49 years\" != \"this year\" (it could be Nov 30th).\r\n\t// Still including them here for `Intl.RelativeTimeFormat` polyfill.\r\n\r\n\t// \"yesterday\".\r\n\t//\r\n\t// \"the day before yesterday\".\r\n\t// For example, in German it's \"Vorgestern\".\r\n\t//\r\n\t// etc.\r\n\t//\r\n\tlet previousIndex = 1\r\n\twhile (rulesCLDR[`relative-type--${previousIndex}`]) {\r\n\t\trules[`previous${previousIndex === 1 ? '' : '-' + previousIndex}`] = rulesCLDR[`relative-type--${previousIndex}`]\r\n\t\tpreviousIndex++\r\n\t}\r\n\r\n\t// \"today\"\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relative-type-0']) {\r\n\t\trules.current = rulesCLDR['relative-type-0']\r\n\t}\r\n\r\n\t// \"tomorrow\".\r\n\t//\r\n\t// \"the day after tomorrow\".\r\n\t// For example, in German it's \"Ãœbermorgen\".\r\n\t//\r\n\t// etc.\r\n\t//\r\n\tlet nextIndex = 1\r\n\twhile (rulesCLDR[`relative-type-${nextIndex}`]) {\r\n\t\trules[`next${nextIndex === 1 ? '' : '-' + nextIndex}`] = rulesCLDR[`relative-type-${nextIndex}`]\r\n\t\tnextIndex++\r\n\t}\r\n\r\n\t// Formatting past times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-past\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"{0} mo. ago\",\r\n\t// \t\"relativeTimePattern-count-other\": \"{0} mo. ago\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relativeTime-type-past'])\r\n\t{\r\n\t\tconst past = rulesCLDR['relativeTime-type-past']\r\n\t\trules.past = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(past)) {\r\n\t\t\trules.past[quantifier.replace('relativeTimePattern-count-', '')] = past[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.past)) {\r\n\t\t\tif (quantifier !== 'other' && rules.past[quantifier] === rules.past.other) {\r\n\t\t\t\tdelete rules.past[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.past).length === 1) {\r\n\t\t\trules.past = rules.past.other\r\n\t\t}\r\n\t}\r\n\r\n\t// Formatting future times.\r\n\t//\r\n\t// E.g.:\r\n\t//\r\n\t// \"relativeTime-type-future\":\r\n\t// {\r\n\t// \t\"relativeTimePattern-count-one\": \"in {0} mo.\",\r\n\t// \t\"relativeTimePattern-count-other\": \"in {0} mo.\"\r\n\t// }\r\n\t//\r\n\t/* istanbul ignore else */\r\n\tif (rulesCLDR['relativeTime-type-future'])\r\n\t{\r\n\t\tconst future = rulesCLDR['relativeTime-type-future']\r\n\t\trules.future = {}\r\n\r\n\t\t// Populate all quantifiers (\"one\", \"other\", etc).\r\n\t\tfor (const quantifier of Object.keys(future)) {\r\n\t\t\trules.future[quantifier.replace('relativeTimePattern-count-', '')] = future[quantifier]\r\n\t\t}\r\n\r\n\t\t// Delete all duplicates of \"other\" rule.\r\n\t\tfor (const quantifier of Object.keys(rules.future)) {\r\n\t\t\tif (quantifier !== 'other' && rules.future[quantifier] === rules.future.other) {\r\n\t\t\t\tdelete rules.future[quantifier]\r\n\t\t\t}\r\n\t\t}\r\n\r\n \t\t// If only \"other\" rule is present then \"rules\" is not an object and is a string.\r\n\t\tif (Object.keys(rules.future).length === 1) {\r\n\t\t\trules.future = rules.future.other\r\n\t\t}\r\n\t}\r\n\r\n\t// // If `.past` === `.future` then replace them with `.other`.\r\n\t// // (only eligible for \"tiny\" and \"*-time\" locale data which is not part of CLDR)\r\n\t// if (isEqual(rules.past, rules.future)) {\r\n\t// \trules.other = rules.past\r\n\t// \tdelete rules.future\r\n\t// }\r\n\r\n\t// // If only \"other\" rule is defined for a time unit\r\n\t// // then make \"rules\" a string rather than an object.\r\n\t// if (Object.keys(rules).length === 1) {\r\n\t// \trules = rules.other\r\n\t// }\r\n\r\n\treturn rules\r\n}\r\n\r\n/**\r\n * Sets time unit formatting rules in locale data.\r\n * @param {object} localeData\r\n * @param {string} type\r\n * @param {string} unit\r\n * @param {object} rules\r\n * @return {object} Locale data.\r\n */\r\nfunction setUnitRules(localeData, type, unit, rules) {\r\n\tif (!localeData[type]) {\r\n\t\tlocaleData[type] = {}\r\n\t}\r\n\tlocaleData[type][unit] = rules\r\n\treturn localeData\r\n}\r\n\r\n/**\r\n * Parses CLDR time unit into `unit` and `type`.\r\n * @param  {string} CLDR_unit\r\n * @return {object} `{ type, unit }`.\r\n */\r\nfunction parseUnit(unit) {\r\n\tif (narrow.test(unit)) {\r\n\t\treturn { type: 'narrow', unit: unit.replace(narrow, '') }\r\n\t}\r\n\tif (short.test(unit)) {\r\n\t\treturn { type: 'short', unit: unit.replace(short, '') }\r\n\t}\r\n\treturn { type: 'long', unit }\r\n}"],"file":"extractRelativeTimeMessages.js"}